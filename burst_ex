#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <getopt.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <pthread.h>


typedef struct{
	int lines_read;
	char** lines_pos;
}thread_result;

typedef struct{
	char* data;
	ssize_t size;
}string;

void write_lines(char* data, ssize_t data_size, int new_lines, char** lines_pos){
	if(lines_written == -1){
		next_file();
		lines_written = 0;	
	}
	
	lines_written += new_lines;
	int overflow = lines_written - max_lines;
	if(overflow > 0){
		//split up the max_lines
		char* final_line = lines_pos[new_lines - overflow - 1];
		write(file_fd, data, final_line-data+1);
		//make a new file
		next_file();
		
		//write in a completely new file
		lines_written = 0;
		write_lines(final_line+1, data+data_size-final_line-1, overflow, lines_pos+new_lines-overflow);
	}else if(overflow == 0){
		//write the leftover to the next file
		char* final_line = lines_pos[new_lines-1];
		write(file_fd, data, final_line-data+1);
		
		//this may be the last character, We are just about to make the next file
		if(final_line == data+data_size-1){
			lines_written = -1;
		}else{
			next_file();
			write(file_fd, final_line+1, data+data_size-final_line+1);
		}

	}else{
		//write all the data
		write(file_fd, data, data_size);
	}
}

void* thread_process(string* in){
	thread_result* res = malloc(sizeof(thread_result));
	if(res == NULL){
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	res->lines_read = 0;
	res->lines_pos = malloc(sizeof(char*)*2);
	if(res->lines_pos == NULL){
		perror("malloc");
		exit(EXIT_FAILURE);
	}
	size_t lines_pos_capacity = 2;
	
	char* s = in->data;
	while((s = memchr(s, '\n', (in->data-s) + in->size))){
		res->lines_read++;
		if(res->lines_read > lines_pos_capacity){
			lines_pos_capacity *= 2;
			res->lines_pos = realloc(res->lines_pos, sizeof(char*)*lines_pos_capacity);
		}
		res->lines_pos[res->lines_read-1] = s;
		if(++s == in->data + in->size) break;
	}
	
	return res;
}



int main(int argc, char* argv[]) {
    int choice;
    while ((choice = getopt(argc, argv, "-l:j:b:xh")) != -1) {
        switch (choice) {
            case 1:
                ip = open(optarg, O_RDONLY);
                if (ip == -1) {
                    perror(optarg);
                    exit(EXIT_FAILURE);
                }
                size_t len = strlen(optarg);
                file_name = malloc(len + 1);
                if (file_name == NULL) {
                    perror("malloc");
                    exit(EXIT_FAILURE);
                }
                strcpy(file_name, optarg);
                break;
            case 'l':
                max_lines = atoi(optarg);
                if (max_lines < 1) max_lines = 500;
                break;

            case 'j':
                no_of_jobs = atoi(optarg);
                if (no_of_jobs < 1) no_of_jobs = 2;
                break;
	    case 'b':
				buff_size = atoi(optarg);
				if(buff_size < 1) buff_size = BUFSIZ;
				break;
			case 'x':
				ovwrt = 1;
				break;
			case 'h':
				help();
				exit(EXIT_SUCCESS);
			case '?':
				write(2, "Try 'burst -h' for more information\n", 36);
				exit(EXIT_FAILURE);
        }
    }
}